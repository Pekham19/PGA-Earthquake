# pga_times_divided_batch_fixed.py
import os, glob, warnings
import numpy as np
import rasterio
from rasterio.warp import reproject, Resampling
from tqdm import tqdm

warnings.filterwarnings("ignore")

# ---------------- EDIT THESE PATHS ----------------
PGA_TIF      = r"You want to multiply with this  file"
DIVIDED_DIR  = r"file  you have the all files"
OUT_DIR      = r"Out"
GLOB_PATTERN = "*.tif"
# -------------------------------------------------

os.makedirs(OUT_DIR, exist_ok=True)

F32_MAX = np.finfo(np.float32).max

def safe_nodata_for_float32(nodata_value):
    """
    Return a nodata suitable for float32 outputs.
    If nodata is None, NaN is fine for float32.
    If nodata is +/-inf, NaN, or beyond float32 range, use NaN.
    Otherwise return the value.
    """
    if nodata_value is None:
        return np.float32(np.nan)
    if not np.isfinite(nodata_value):
        return np.float32(np.nan)
    if abs(nodata_value) > F32_MAX:
        return np.float32(np.nan)
    return np.float32(nodata_value)

def reproject_to_ref(src_path, ref_profile):
    """Reproject src raster (band 1) to reference grid defined by ref_profile."""
    with rasterio.open(src_path) as src:
        src_nodata = src.nodata
        dst = np.full((ref_profile["height"], ref_profile["width"]), np.nan, dtype=np.float32)

        reproject(
            source=rasterio.band(src, 1),
            destination=dst,
            src_transform=src.transform,
            src_crs=src.crs,
            src_nodata=src_nodata,
            dst_transform=ref_profile["transform"],
            dst_crs=ref_profile["crs"],
            dst_nodata=np.nan,  # standardize to NaN in working grid
            resampling=Resampling.bilinear
        )
    return dst  # contains NaNs where source was nodata

def process_one(divided_path, pga_arr, pga_valid_mask, ref_profile, out_nodata):
    """Compute output = PGA * DIVIDED where DIVIDED valid else PGA."""
    div_arr = reproject_to_ref(divided_path, ref_profile)
    div_valid = np.isfinite(div_arr)

    out = pga_arr.astype(np.float32).copy()

    multiply_mask = pga_valid_mask & div_valid
    out[multiply_mask] = (pga_arr[multiply_mask] * div_arr[multiply_mask]).astype(np.float32)

    # Keep PGA NoData wherever PGA was invalid
    invalid_pga = ~pga_valid_mask
    if np.isnan(out_nodata):
        out[invalid_pga] = np.nan
    else:
        out[invalid_pga] = out_nodata

    return out

def main():
    with rasterio.open(PGA_TIF) as psrc:
        pga_profile = psrc.profile.copy()
        pga_arr = psrc.read(1)  # keep original dtype for mask creation
        pga_nodata_src = psrc.nodata

        # Valid where finite and not equal to declared nodata (if any)
        if pga_nodata_src is None:
            pga_valid_mask = np.isfinite(pga_arr)
        else:
            pga_valid_mask = np.isfinite(pga_arr) & (pga_arr != pga_nodata_src)

        # Prepare output profile: float32 + safe nodata (NaN if needed)
        out_nodata = safe_nodata_for_float32(pga_nodata_src)
        pga_profile.update(
            dtype="float32",
            count=1,
            compress="LZW",
            predictor=2,
            BIGTIFF="IF_SAFER",
            nodata=float(out_nodata)  # OK to be NaN for float32
        )

    divided_paths = sorted(glob.glob(os.path.join(DIVIDED_DIR, GLOB_PATTERN)))
    if not divided_paths:
        print("No divided rasters found. Check DIVIDED_DIR and GLOB_PATTERN.")
        return

    for dpath in tqdm(divided_paths, desc="Processing"):
        try:
            out_arr = process_one(dpath, pga_arr, pga_valid_mask, pga_profile, out_nodata)

            base = os.path.splitext(os.path.basename(dpath))[0]
            out_name = f"PGAx_{base}.tif"
            out_path = os.path.join(OUT_DIR, out_name)

            with rasterio.open(out_path, "w", **pga_profile) as dst:
                dst.write(out_arr.astype(np.float32), 1)

        except Exception as e:
            print(f"Failed on {dpath}: {e}")

    print(f"Done. Outputs in: {OUT_DIR}")

if __name__ == "__main__":
    main()
